from pathlib import Path

path = Path('src/bot.js')
text = path.read_text(encoding='utf-8')
needle = "function languageSelectionKeyboard() {\n  return Markup.inlineKeyboard([\n    [\n      Markup.button.callback('🇷🇺 Русский', 'language:ru'),\n      Markup.button.callback('🇬🇧 English', 'language:en'),\n    ],\n  ]);\n}\n\n"
if needle not in text:
    raise SystemExit('languageSelectionKeyboard block not found')

helpers = "const MAX_SIP_OPTIONS = 25;\n\nfunction encodeCallbackComponent(value) {\n  return encodeURIComponent(String(value));\n}\n\nfunction decodeCallbackComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    return value;\n  }\n}\n\nfunction chunk(array, size) {\n  const result = [];\n  for (let index = 0; index < array.length; index += size) {\n    result.push(array.slice(index, index + size));\n  }\n  return result;\n}\n\nfunction parseSipRange(value) {\n  if (!value) {\n    return [];\n  }\n\n  const matches = [...String(value).matchAll(/(\\d{2,})\\s*[-–]\\s*(\\d{2,})/g)];\n\n  for (const match of matches) {\n    const start = Number(match[1]);\n    const end = Number(match[2]);\n\n    if (\n      Number.isFinite(start) &&\n      Number.isFinite(end) &&\n      end >= start &&\n      end - start + 1 <= MAX_SIP_OPTIONS\n    ) {\n      const options = [];\n      for (let cursor = start; cursor <= end; cursor += 1) {\n        options.push(String(cursor));\n      }\n      if (options.length) {\n        return options;\n      }\n    }\n  }\n\n  return [];\n}\n\nfunction getSipOptions(line) {\n  if (!line) {\n    return [];\n  }\n\n  const sources = [line.title, line.id];\n  for (const source of sources) {\n    const options = parseSipRange(source);\n    if (options.length) {\n      return options;\n    }\n  }\n\n  return [];\n}\n\nfunction formatLineButtonLabel(line) {\n  if (line.title && line.title !== line.id) {\n    return 📞  ();\n  }\n  return 📞 ;\n}\n\nfunction buildSipKeyboard(line, options, language) {\n  const rows = chunk(options, 3).map((group) =>\n    group.map((sip) =>\n      Markup.button.callback(\n        ☎️ ,\n        complaintSip::\n      )\n    )\n  );\n\n  rows.push([\n    Markup.button.callback(\n      t(language, 'backButton'),\n      complaintBack:\n    ),\n  ]);\n\n  return Markup.inlineKeyboard(rows);\n}\n\nasync function sendComplaintLineMenu(ctx, user, language, { edit = false } = {}) {\n  const lines = await repository.getLines();\n  const userLines = lines.filter((line) => user.lineIds.includes(line.id));\n\n  if (!userLines.length) {\n    await ctx.reply(t(language, 'notLinked'));\n    return;\n  }\n\n  const keyboard = Markup.inlineKeyboard(\n    userLines.map((line) => [\n      Markup.button.callback(\n        formatLineButtonLabel(line),\n        complaint:\n      ),\n    ])\n  );\n\n  const text = t(language, 'complaintPrompt');\n  if (edit) {\n    try {\n      await ctx.editMessageText(text, keyboard);\n    } catch (error) {\n      await ctx.reply(text, keyboard);\n    }\n  } else {\n    await ctx.reply(text, keyboard);\n  }\n}\n\n"

text = text.replace(needle, needle + helpers)
path.write_text(text, encoding='utf-8')
